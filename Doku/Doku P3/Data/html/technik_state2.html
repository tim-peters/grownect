	<div id="kopfleiste">
		<img src="Bilder/Logo grownect.png" height="60" style="margin-left:20px">
	</div>
	

<div id="infobox">
<ul>
	<li><strong>Weitere Details</strong></li>
	<br> 
	<li> Zu Armband: Auflistung benötigter Sensoren aus Pad <br> <br>Im Grunde ist die View auf dem Spiegel-Display mit einer Webseite gleichzusetzen.
		<br></li> 
</ul>
</div>


<div id="menu">
		<ul>
			<li><a href="trailer.html">Trailer</a></li>
			<li><a href="connect.html">Connect</a></li>
			<li><a href="recherche.html">Recherche</a></li>
			<li><a href="konzept.html">Konzept</a></li>
			<li><a href="interaktion.html">Interaktion...</a></li>
			<li class="active"><a href="technik.html">Technik</a></li>
			<li><a href="design.html">Design</a></li>
			<li><a href="management.html">Management</a></li>
			<li><a href="kontakt.html">Kontakt</a></li>
		</ul>
	</div>

	<div id="inhalt">
		<h2>KOMMUNIKATION/EVENTBUSSES</h2>

		<p>Warum das System trotzdem streng genommen mehr als eine 3-Tier-Architektur ausmacht, zeigt sich beim Blick auf die Kommunikation der Devices. Diese ist entgegen der klassischen Server-Client-Beziehung zu jeder Zeit bi-direktional möglich. Dies bedeutet, dass nicht nur die Clients Requests an den Server senden können, der daraufhin anfängt zu arbeiten und (im Idealfall) mit dem Code zum anzeigen einer View antwortet, sondern dass auch der Server (ungefragt) Events auf Seite der beiden Clients auslösen kann. Ein solches Vorgehen gibt das http-Protokoll in seiner klassischen Form nicht her. Das System bedient sich hier dem Eventbus-Standard (websockets), ausgerüstet mit zahlreichen Fallbacks zur Gewährleistung der Kompatibilität auch mit alten Systemen. Im Prototyp ist dieser Schritt zur Gewährleistung des bestmöglichen Zeit-Nutzen-Verhältnisses an einen externen Dienstleister (pusher.com) ausgelagert. Dieser stellt die nötige Infrastruktur und eine Schnittstelle zur Verfügung.<br>
		Innerhalb des Systems ist die Kommunikation über den Eventbus sowohl logisch in die Klassenarchitektur integriert (wo sie innerhalb der normalen serverseitigen Berechnungen stattfindet) als auch an einer extra hierfür erstellten Stelle gebündelt. Diese Stelle empfängt zum einen die Antworten der Clients und wertet sie (anfänglich) aus, zum anderen sendet sie die Events aus, die sich unmittelbar aus Antworten von Devices ergeben. Über diesen API-Teil läuft somit ein Großteil der Client-Server-Kommunikation abseits von klassischen HTTP-Requests. Eine Übersicht der Kommunikationsarchitektur findet sich hier (FIXME: Link zur API-Tabelle).</p>
<div class="buttoncentered">
 <a href="" ng-click="back()" ng-show="num > 0"> <button type="button" type="submit" class="btn2"><img src="bilder/back.png" width="25">Zurück</button></a>
  <a href="" ng-click="next()" ng-show="num<content.length-1"> <button type="button" type="submit" class="btn"><img src="bilder/confirm.png" width="25">Weiter</button></a>
</div>
</div>
