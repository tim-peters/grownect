	<div id="kopfleiste">
		<img src="Bilder/Logo grownect.png" height="60" style="margin-left:20px">
	</div>
	

<div id="infobox">
<ul>
	<li><strong>Kommunikation</strong></li>
	<br> 
	<li>Hinweis zur Technik der Eventbusses<br><br><a href="technik.html" style="color:black">Technik</a></li> 
</ul>
</div>


<div id="menu">
		<ul>
			<li><a href="trailer.html">Trailer</a></li>
			<li><a href="connect.html">Connect</a></li>
			<li><a href="recherche.html">Recherche</a></li>
			<li><a href="konzept.html">Konzept</a></li>
			<li class="active"><a href="interaktion.html">Interaktion...</a></li>
			<li><a href="technik.html">Technik</a></li>
			<li><a href="design.html">Design</a></li>
			<li><a href="management.html">Management</a></li>
			<li><a href="kontakt.html">Kontakt</a></li>
		</ul>
	</div>

	<div id="inhalt">
	<img src="./Bilder/states/15.jpg" class="stateImage" />
	<h2>ERINNERUNG</h2>
	<p> Dieses Feature ist nur Möglich wenn der User bei den Gefühlsslidern "sehr sauer" ausgewählt hat. <br><br>
	Durch die Erinnerung wird dem User die Möglichkeit gegeben, seine Entwicklung bezüglich eines immer wieder auftretenden Fehlverhaltens, einer Dusseligekit aufzuzeigen, die ein Kern unserer Anwendung ist. Dies soll in erster Linie zur Selbstreflexion führen und so ferner die intrinsische Motivation aufrecht erhalten. <br><br>
Hinzu kommt der Aspekt, dass ihm, insbesondere bei Komplexeren Problemen durch eine Statistik auch vor Augen geführt werden kann, wie viel Energie er bereits in die Lösung des Problems investiert hat. Somit würde dem Nutzer auch vor aufgezeigt, wie viel Aufwand und Zeit er umsonst aufgebracht hätte, wenn er nun vom Weg der Lösung des Problems abweicht. Es wird ein wenig Druck aufgebaut, der die eigentlich intrinsische Motivation des sich-selbst-Verbesserns, wenn es nötig ist durch extrinsiche Aspekte ergänzt.
<br><br>
Um seine Entwicklung nun einsehen zu können, sieht unser Konzept vor, dass das System erkennt, wann ein bestimmtes Problem potenziell wieder auftritt und den User nun anspricht. Gibt es beispielsweise ein Problem mit der Pünktlichkeit eines Users, wird dieser fortan immer wieder, kurz nach dem Start des Termins gefragt, ob er zu diesem Pünktlich war. Allein durch die Beantwortung dieser Frage wird der User gezwungen, sein eigenes Handeln zu reflektieren und gleichzeitig wird ihm das Problem erneut vor Augen geführt. <br><br>
Entscheidend ist hierbei, dass unser Produkt nicht das Ziel hat, Erinnerungen im klassischen Sinne auszusenden. Es geht weniger darum, den User an nicht erfüllte Verpflichtungen oder Vergessenes zu erinnern, als darum ihn kurz danach zu fragen ob er selbst daran gedacht hat. So wird dem User die Verantwortung in keinem Fall abgenommen. Viel mehr wird der User nur angeregt den Prozess der Verändern, der Selbst-Verbesserung aufrecht zu halten.
<br><br>
Damit unser Produkt den Nutzer nun aber erinnern kann, muss es nicht nur die Situation in der es zum Versäumen kommen könnte kennen, sondern auch erkennen wann diese Situation eintritt. Es muss wissen, nach welchem Parametern es durchgehend tracken muss, um im richtigen Moment zu erkennen, dass der User nun wieder etwas vergessen haben könnte.<br><br>
Ein gesteigertes Interesse daran, dass der User sein Verhalten ändert, hat initial vorallem der User, der sich durch das Verhalten gestört fühlt. Er ist es, der unser Produkt überhaupt ins Spiel bringt. So erscheint es nur logisch, dass dieser andere User es auch ist, der dem vergesslichen User die Lösung mit auf den Weg gibt. Er soll im Prozess der Erstellung eines Problems, insbesondere bei schwerwiegenderen Problemen die Möglichkeit bekommen, zu definieren wann der vergessliche Nutzer erinnert werden soll.
Hierbei standen wir konzeptionell vor verschiedenen Herausforderungen.
<br><br>
Dem User sollte die Möglichkeit gegeben werden beliebe Events zu definieren. Er sollte nicht von einer vorgefertigten Liste abhängig sein. Gleichzeitig mussten die Events aber bestimmten technischen Anforderungen genügen. So musste genug strukturierte Information vorhanden sein, was den Auslöser für eine Erinnerung angeht, dass unser System den vergesslichen Nutzer auf diese Art zum richtigen Zeitpunkt ansprechen könnte.
Diese beiden Anforderungen erschienen vorerst konträr. Die Art der Events beliebig zu halten, hieß dem Nutzer bei der Erstellung weitgehend freie Hand zu lassen - ihn keinesfalls aus nur aus einer vorgefertigten Liste auswählen zu lassen. Auf der anderen Seite, war der Anspruch an die Events höher, als es einem Nutzer, bei dem weder Motivation noch technisches Verständnis sich tiefer mit der Funktionsweise des Trackings auseinanderzusetzen zuzumuten wäre.
<br><br>
Die Lösung fand sich in einer durch ein Baukastensystem erweiterbaren Liste.
<br><br>
Die Idee ist, dass der User zuerst in einer großen Liste suchen kann, ob jemand anders oder erst selbst vorher, dass nötige Event bereit erstellt hat. Ist dies der Fall kann er das gefundene Event einfach übernehmen oder adaptieren.
Gibt es das Event nocht nicht, wird ihm auf möglichst einfache Weise die Möglichkeit geboten das Event selbst zu erstellen und später der Community zur Verfügung zu stellen.

<br><br>
Grundlegend muss der User hierzu nur Bedingungen per Drag-and-Drop kombinieren um so zu definieren wann das Event ausgelöst wird. Eine Bedingungen kann hierbei viele verschiedene Formen haben. So kann sie beispielsweise räumlich verknüpft sein (“wenn er sich an einem bestimmten Ort aufhält…”), auf externen Daten aufbauen (“wenn er einen Termin in seinem Google-Kalender hat…”), von Sensoren abhängen (“Wenn der Sensor im Bad anzeigt, dass kein Toilettenpapier mehr vorhanden ist…”) oder sogar zufällig sein (“Alle 3 bis 5 Tage…”).
Erst die Kombination verschiedener Bedienungen zeichnet ein technischen Bild der Situation in der das Problem auftritt. Gleichzeitig sind die einzelnen Bedingungen aber noch so offen, so vielfältig, dass sie in unterschiedlicher Kombination ganz verschiedene Event ergeben können.
Sollten die vorhandenen Bedingungen aber trotzdem einmal nicht ausreichen, oder kommt beispielsweise neue Hardware ins Haus, die nun auch eingebunden werden soll, so soll der (etwas technisch versiertere) User auch die Möglichkeit haben selbst Bedingungen zu erstellen und mit anderen zu teilen. <br><br>
Der große Vorteil des Baukastenprinzips ist, dass sich das System fortlaufend weiterentwickelt. Mit jeder neuen Bedingung, mit jedem eingebundenen Sensor bieten sich multiple neue Möglichkeiten für Events. Der Ersteller einer Bedingung muss hierbei mit Nichten alle Anwendungsfälle seiner Bedingung kennen. Entscheidend ist die Kreativität der User.

</p>
	</div>
<div class="buttonbox">
 <a href="" ng-click="back()" ng-show="num > 0"> <button type="button" type="submit" class="btn2"><img src="bilder/back.png" width="25">Zurück</button></a>
  <a href="" ng-click="next()" ng-show="num<content.length-1"> <button type="button" type="submit" class="btn"><img src="bilder/confirm.png" width="25">Weiter</button></a>
</div>